
**Процесс** в Linux (как и в UNIX) это - программа, которая выполняется в отдельном защищенном виртуальном адресном пространстве.

Часть времени процесс выполняется в режиме задачи ( пользовательском режиме ) и тогда он выполняет собственный код, часть времени процесс выполняется в режиме ядра и тогда он выполняет реентерабельный код операционной системы.

В Linux поддерживается классическая схема мультипрограммирования. Linux поддерживает параллельное (или квазипараллельное при наличии только одного процессора) выполнение процессов пользователя. Каждый процесс выполняется в собственном защищенном виртуальном адресном пространстве. Это значит, что ни один процесс не обратиться в адресное пространство другого процесса.   Процессы защищены друг от друга и крах одного процесса никак не повлияет на другие выполняющиеся процессы и на всю систему в целом.

Ядро предоставляет системные вызовы для создания новых процессов и для управления запущенными процессами. Любая программа может начать выполняться только если другой **процесс ее запустит.**

Для создания процессов используется системный вызов **fork().** 

Системный вызов fork() создает новый процесс (рис.1), кE3оторый является копией процесса-предка: процесс-потомок наследует адресное пространство  процесса-предка, дескрипторы всех открытых файлов и сигнальную маску и т.д.

Процесс потомок имеет идентичные с родителем области данных и стека. Процесс-потомок начинает работу в режиме задачи после возвращения из системного вызова fork(). 

Так как fork()  возвращает дочернему процессу число 0, а родительскому —  PID (Process IDentifier — идентификатор процесса) дочернего процесса. ==> можем различить эти процессы хоть у нас одинаковые регистры данные переменные ид

```C
#include <sys/types.h>
#include <unistd.h>
int main(void)
{
pid_t childpid ; /* если fork завершился успешно, pid > 0 в родительском процессе */
if ((childpid = fork( )==-1) 
{
     perror(“Can't fork”); /* fork потерпел неудачу (например, память или какая-либо */
     exit(1)                         /*таблица заполнена) */
} 
else if (childpid == 0)
 {
     /* здесь располагается код процесса-потомка */
 } else
    {
       /* здесь располагается родительский код */
    }
return 0;
}
```

### **_Рассмотрим более подробно, что же делается при выполнении вызова fork():_**
   
1. Резервируется пространство свопинга для данных и стека процесса-потомка;
2. Назначается идентификатор процесса PID и структура proc потомка;
3. Инициализируется структура proc потомка. Некоторые поля этой структуры копируются от процесса-родителя: идентификаторы пользователя и группы, маски сигналов и группа процессов. Часть полей инициализируется 0. Часть полей инициализируется специфическими для потомка значениями: PID потомка и его родителя, указатель на структуру proc родителя;
4. Создаются карты трансляции адресов для процесса-потомка;
5.  Выделяется область u потомка и в нее копируется область u процесса-предка;
6. Изменяются ссылки области u на новые карты адресации и пространство свопинга;
7. Потомок добавляется в набор процессов, которые разделяют область кода программы, выполняемой процессом-родителем;
8. Постранично дублируются области данных и стека родителя и модифицируются карты адресации потомка;
9. Потомок получает ссылки на разделяемые ресурсы, которые он наследует: открытые файлы (потомок наследует дескрипторы) и текущий рабочий каталог;
10. Инициализируется аппаратный контекст потомка путем копирования регистров родителя;
11. Поместить процесс-потомок в очередь готовых процессов;
12. Возвращается PID в точку возврата из системного вызова в родительском процессе и 0 - в процессе-потомке.

**Еще раз об оптимизации fork()**

Системный вызов **fork**() должен предоставить процессу-потомку логически идентичную копию адресного пространства его родителя. В большинстве случаев потомок заменяет предоставленное адресное пространство, так как сразу же после выполнения fork вызывает exec или exit. Таким образом, создание копии адресного пространства (так, как это реализовано в первых системах UNIX) является не оптимальной процедурой.

Вышеописанная проблема была решена двумя различными способами. 
Сначала был разработан метод копирования при записи (copy-on-write), 
впервые реализованный в ОС **System** V и в настоящий момент используемый в 
большинстве систем UNIX и LINUX.
 При таком подходе:
- страницы данных и стека родителя временно получают атрибут «только для чтения» и маркируются как «копируемые при записи»;
-  потомок получает собственные карты трансляции адресов ( таблицы страниц ), которые ссылаются на страницы процесса-предка, т.е. процесс-потомок  использует одни и те же страницы памяти вместе со своим родительским процессом; 
- если кто-то из них (родитель или потомок) попытается изменить страницу памяти, произойдет ошибочная исключительная ситуация по правам доступа, так как страницы доступны только для чтения. Затем ядро системы запустит обработчик исключительной ситуации, который обнаружит, что страница помечена как «копируемая при записи», и создаст новую ее новую копию, которую уже можно изменять. 

- Таким образом, происходит копирование только тех страниц памяти, которые требуется изменять, а не всего адресного пространства целиком. 
Если потомок вызовет exec() или exit(), то защита страниц памяти вновь станет обычной, и флаг «копирования при записи» будет сброшен. 
В

**системе BSD UNIX** представлен несколько иной подход к решению проблемы, реализованный в новом системном вызове **vfork(). Функция vfork()** не производит копирования. Вместо этого процесс-родитель предоставляет свое адресное пространство потомку (потомок получает карты трансляции адресов предка ) и блокируется до тех пор, пока тот не вернет его. Затем происходит выполнение потомка в адресном пространстве родительского процесса до того времени, пока не будет произведен вызов exec или exit(), после чего ядро вернет родителю его адресное пространство и выведет его из состояния сна. Системный вызов vfork() выполняется очень быстро, так как не копирует даже карты адресации. Адресное пространство передается потомку простым копированием регистров карты адресации. Однако следует отметить, что вызов vfork является достаточно опасным, так как позволяет одному процессу использовать и даже изменять адресное пространство другого процесса. Это свойство vfork используют различные программы, такие как csh. 
Программист может воспользоваться **vfork() вместо fork(),** если планирует вслед за ним сразу вызвать exec().

![img.png](img.png)


 ## Процесс-сирота
Системный вызов fork() создает новый процесс – процесс-потомок.
Отношение родитель – потомок создает иерархию процессов (см. указатели на потомков в struct proc). Если родительский процесс завершается раньше своих потомков, то в системе выполняется так называемое усыновление: процесс-потомок усыновляется процессом с идентификатором 1 (процессом «открывшим» терминал и создавшим терминальную группу) или в Ubuntu процессом-посредником systemd –user, который в итоге является потомком процесса с идентификатором 1.

# Задание:
Написать программу, запускающую не мене двух новых процессов системным вызовом fork(). В предке вывести собственный идентификатор (функция getpid()), идентификатор группы ( функция getpgrp())  и идентификаторы потомков. В процессе-потомке вывести собственный идентификатор, идентификатор предка (функция getppid()) и идентификатор группы. Убедиться, что при завершении процесса-предка потомок, который продолжает выполняться, получает идентификатор предка (PPID), равный 1 или идентификатор процесса-посредника.




## Ожидание процессом - предком завершения потомков. Системный вызов wait().
**Cистемный вызов wait()** блокирует родительский процесс до момента завершения дочернего. При этом процесс-предок получает статус завершения процесса-потомка.
```C
#include <sys/types.h>
#include <sys/wait.h>
pid_t wait(int *stat_loc);
```

Вызов возвращает PID дочернего процесса. Обычно это дочерний процесс, который завершился. Сведения о состоянии позволяют родительскому процессу определить статус завершения дочернего процесса, т.е. значение, возвращенное из функции main потомка или переданное функции exit(). Если stat_loc не равен пустому указателю, информация о состоянии будет записана в то место, на которое указывает этот параметр.


![img_1.png](img_1.png)


```C

#include <sys/types.h>
#include <sys/wait.h>
В следующем фрагменте программы процесс ждет окончания дочернего процесса:
 if (pid > 0) {
  int status;
  pid_t child_pid;
  child_pid = wait(&status);
  printf("Child has finished: PID = %d\n", child_pid);
  if (WIFEXITED(stat_val))
   printf("Child exited with code %d\n", WEXITSTATUS(stat_val));
  else printf("Child terminated abnormally\n");
 }

```


Есть еще один системный вызов, который можно применять для ожидания дочернего процесса. Он называется waitpid() и применяется для ожидания завершения определенного процесса.
#include <sys/types.h>
#include <sys/wait.h>
pid_t **waitpid**(pid_t pid, int *stat_loc, int options);

Аргумент pid — конкретный дочерний процесс, окончания которого нужно ждать. Если он равен –1, waitpid()  возвращает  информацию о любом дочернем процессе. Как и вызов wait(), он записывает информацию о состоянии процесса в то место, которое указывает аргумент stat_loc, если последний не равен пустому указателю. Аргумент options позволяет изменить поведение waitpid. Наиболее полезная опция WNOHANG мешает вызову waitpid() приостанавливать выполнение вызвавшего его процесса. Она применяется для определения, завершился ли какой-либо из дочерних процессов, и если нет, то можно продолжить выполнение. Остальные опции такие же, как в вызове wait().
И так для того, чтобы родительский процесс периодически проверял, завершился ли конкретный дочерний процесс, можно использовать следующий вызов:

waitpid(child_pid, (int *)0, WNOHANG);


Он вернет ноль, если дочерний процесс не завершился и не остановлен, или child_pid, если это произошло. Вызов waitpid вернет -1 в случае ошибки и установит переменную errno. Это может произойти, если нет дочерних процессов (errno равна ECHILD), если вызов прерван сигналом (EINTR) или аргумент options неверный (EINVAL)


**Задание 2:** 
написать программу по схеме первого задания, но в процессе-предке выполнить системный вызов wait(). Убедиться, что в этом случае идентификатор процесса потомка на 1 больше идентификатора процесса-предка.


## Системный вызов exec()
Чаще всего нет смысла в выполнении двух одинаковых процессов и потомок сразу выполняет системный вызов exec(), параметрами которого является имя исполняемого файла и, если нужно, параметры, которые будут переданы этой программе.
Говорят, что системный вызов exec() создает низкоуровневый процесс: создаются таблицы страниц для адресного пространства программы, указанной в exec(), но программа на выполнение не запускается, так как это не полноценный процесс, имеющий идентификатор и дескриптор. Системный вызов exec() создает таблицу страниц для адресного пространства программы, переданной ему в качестве параметра, а затем заменяет старый адрес новой таблицы страниц.

![img_3.png](img_3.png)

## Процессы «зомби»

Применение вызова fork() для создания процессов может оказаться очень полезным, но  необходимо отслеживать дочерние процессы. Когда дочерний процесс завершается, связь его с родителем сохраняется до тех пор, пока родительский процесс в свою очередь не завершится нормально, или не вызовет wait(). Следовательно, запись о дочернем процессе не исчезает из таблицы процессов немедленно. Становясь неактивным, дочерний процесс все еще остается в системе, поскольку его код завершения должен быть сохранен, на случай если родительский процесс в дальнейшем вызовет wait().
Процесс-зомби – это процесс, у которого отобраны все ресурсы, кроме последнего – строки в таблице процессов. Это сделано для того, чтобы процесс-предок, вызвавший системный вызов wait(), не был заблокирован навсегда.
Можно увидеть переход процесса в состояние зомби, если дочерний процесс завершиться первым, то он будет существовать как зомби, пока процесс-предок или вызовет системный вызов wait(), или  родительский процесс завершиться.



## Задание 3:
Написать программу, в которой процесс-потомок вызывает системный вызов exec(), а процесс-предок ждет завершения процесса-потомка. Следует создать не менее двух потомков.

## Программные каналы

Системный вызов pipe() создает неименованный программный канал. Неименованные программные каналы могут использоваться для обмена сообщениями между процессами родственниками. В отличие от именованных программных каналов неименованные не имеют идентификатора, но имеют дескриптор. Процесс-потомок наследует все дескрипторы открытых файлов процесса-предка, в том числе и неименованных программных каналов.
Программные каналы имеют встроенные средства взаимоисключения — массив файловых дескрипторов: из канала нельзя читать, если в него пишут, и в канал нельзя писать, если из него читают. Для этого определяется массив файловых дескрипторов, как показано в примере:
```C
int fd[2];
pipe(fd);
if (( pid=fork())<0)
{
    err_sys(“Error fork()”);
}
else if (pid==0)
{
    /*child*/
    close(fd[0]);
    write(fd[1], … );
}
else {
    /*parent*/
    close(fd[1]);
    read(fd[0], … );
}
```
## Задание 4:
Написать программу, в которой предок и потомок обмениваются сообщением через программный канал.